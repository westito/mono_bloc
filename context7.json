{
  "$schema": "https://context7.com/schema/context7.json",
  "projectTitle": "MonoBloc",
  "description": "Pure Dart code generator for Bloc pattern that eliminates boilerplate by defining events as methods with built-in concurrency control and action side-effects",
  "folders": [
    "mono_bloc/lib",
    "mono_bloc_generator/lib",
    "mono_bloc_hooks/lib",
    "mono_bloc_flutter/lib"
  ],
  "excludeFolders": [
    "example",
    "test",
    "scripts",
    ".dart_tool",
    "build",
    "mono_bloc/example",
    "mono_bloc_generator/test",
    "mono_bloc_hooks/example"
  ],
  "excludeFiles": [
    "CHANGELOG.md",
    "IMPORT_GUIDE.md",
    "pubspec.lock"
  ],
  "rules": [
    "# Core Annotations",
    "@MonoBloc() - Marks a class for code generation. Creates base class _$YourBloc with event handlers",
    "@MonoBloc(sequential: true) - All events process sequentially, waiting for each to complete before starting next",
    "@MonoBloc(concurrency: MonoConcurrency.restartable) - Set default concurrency mode for all events. Options: concurrent, sequential, restartable, droppable",
    "@event - Marks a private method as an event handler. Generates public method without underscore/prefix",
    "@MonoActions() - Marks a private mixin containing action side-effect methods (navigation, dialogs). All abstract void methods become actions automatically",
    "@onError - Global error handler for all events. Specific handlers: _onError{EventName}(error, stackTrace)",
    "@onInit - Runs automatically when bloc is created. Use for initial data loading",
    "",
    "# Event Return Types",
    "Methods annotated with @event can return: State, Future<State>, Stream<State>, void with _Emitter emit, or Future<void> with _Emitter emit",
    "Example: @event int _onIncrement() => state + 1;",
    "Example: @event Future<TodoState> _onLoadTodos() async { final todos = await repository.fetchTodos(); return TodoState(todos: todos); }",
    "Example Stream: @event Stream<SearchState> _onSearch(String query) async* { yield state.copyWith(isSearching: true); final results = await repository.search(query); yield state.copyWith(isSearching: false, results: results); }",
    "Calling events: generated methods remove underscore and prefix. bloc.increment() calls _onIncrement, bloc.loadTodos() calls _onLoadTodos",
    "",
    "# Actions Pattern",
    "For side effects (navigation, dialogs, notifications) use @MonoActions() annotation on a private mixin. All abstract void methods become actions automatically",
    "Actions require a private mixin: @MonoActions() mixin _MyBlocActions { void navigateToCheckout(); void showNotification(String message); }",
    "Bloc mixes in the actions mixin: @MonoBloc() class MyBloc extends _$MyBloc<MyState> with _MyBlocActions { MyBloc() : super(MyState()); }",
    "",
    "# Actions - when() Pattern",
    "Use inline callbacks: MonoBlocActionListener<MyBloc>(actions: MyBlocActions.when(navigateToCheckout: (context) => Navigator.pushNamed(context, '/checkout'), showNotification: (context, msg) => ScaffoldMessenger.of(context).showSnackBar(...)), child: ...)",
    "",
    "# Actions - of() Pattern",
    "Implement the generated actions interface for cleaner code: class MyPage extends StatelessWidget implements MyBlocActions { @override void navigateToCheckout(BuildContext context) { Navigator.pushNamed(context, '/checkout'); } @override Widget build(BuildContext context) { return MonoBlocActionListener<MyBloc>(actions: MyBlocActions.of(this), child: ...); } }",
    "When to use: when() for simple pages with few actions, of() for complex pages or reusable handlers",
    "",
    "# Async State Management",
    "Use @AsyncMonoBloc() for automatic loading/error states",
    "Example: @AsyncMonoBloc() class MyBloc extends _$MyBloc<List<Item>> { MyBloc() : super(const MonoAsyncValue.withData([])); @event Future<List<Item>> _onLoad() async { return await repository.fetchItems(); } }",
    "State accessors: state.isLoading, state.hasError, state.dataOrNull, state.data",
    "",
    "# Async Helpers (in @AsyncMonoBloc event handlers)",
    "loading() - Loading state, preserves current data",
    "loadingClearData() - Loading state, clears data",
    "withData(T) - Success state with data",
    "withError(error, stack, [data]) - Error state, optionally preserves data",
    "Example Stream: @restartableEvent Stream<_State> _onSearch(String query) async* { yield loading(); try { final items = await repository.search(query); yield withData(items); } catch (e, stack) { yield withError(e, stack, state.dataOrNull); } }",
    "Example Emitter: @event Future<void> _onRefresh(_Emitter emit) async { emit.loadingClearData(); try { final items = await repository.fetchItems(); emit(items); } catch (e, stack) { emit.error(e, stack); } }",
    "",
    "# @onInit - Initialization",
    "Run code automatically when bloc is created. Init methods should return void and dispatch events",
    "Example: @onInit void _onInit() { loadItems(); }",
    "",
    "# Flutter Hooks",
    "Use mono_bloc_hooks package for cleaner action handling in HookWidget",
    "Example with when(): final bloc = useBloc<MyBloc>(); useMonoBlocActionListener(bloc, MyBlocActions.when(myAction: (context, param) { /* Handle */ }));",
    "Example with of(): class MyPage extends HookWidget implements MyBlocActions { @override Widget build(BuildContext context) { final bloc = useBloc<MyBloc>(); useMonoBlocActionListener(bloc, MyBlocActions.of(this)); return ...; } @override void myAction(BuildContext context, String param) { /* Handle */ } }",
    "",
    "# Required Imports",
    "For bloc declarations: import 'package:mono_bloc/mono_bloc.dart'; part 'my_bloc.g.dart';",
    "For Flutter widgets using actions: import 'package:mono_bloc_flutter/mono_bloc_flutter.dart';",
    "Generator auto-detects Flutter projects and adds BuildContext to action handlers. mono_bloc exports bloc and @protected/@immutable from meta. mono_bloc_flutter exports flutter_bloc + mono_bloc",
    "",
    "# Event Method Naming",
    "Private event methods start with _ and use camelCase: _onIncrement, _onLoadTodos, _onSubmitOrder",
    "Generated public methods remove underscore and prefix: increment(), loadTodos(), submitOrder()",
    "",
    "# Concurrency Control",
    "@MonoBloc(concurrency: MonoConcurrency.X) - Set default concurrency for all events. Events with explicit annotations override this default",
    "@restartableEvent - Cancel ongoing event when new one arrives (for search/filter)",
    "@droppableEvent - Ignore new events while one is processing (for submit/save)",
    "@sequentialEvent - Process events one at a time, waiting for each to complete",
    "@concurrentEvent - Process all events simultaneously (default)",
    "MonoConcurrency options: concurrent (default), sequential, restartable, droppable",
    "",
    "# Error Handling Priority",
    "Event-specific error handler (_onErrorEventName) takes priority over global error handler (_onError)",
    "Example: @onError MyState _onErrorAddItem(Object error, StackTrace stackTrace) { return ErrorState('Failed to add item: $error'); }",
    "",
    "# Event Queues",
    "Use string-based queue names: static const modifyQueue = 'modify'; @MonoEvent.queue(modifyQueue)",
    "Define queue transformers in constructor: TodoBloc() : super(TodoState(), queues: { modifyQueue: MonoEventTransformer.sequential });",
    "",
    "# Build Commands",
    "Generate code: dart run build_runner build --delete-conflicting-outputs",
    "Watch mode: dart run build_runner watch --delete-conflicting-outputs"
  ],
  "previousVersions": []
}
